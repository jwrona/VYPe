/*
 * project: VYPe15 programming language compiler
 * author: Jan Wrona <xwrona00@stud.fit.vutbr.cz>
 * author: Katerina Zmolikova <xzmoli02@stud.fit.vutbr.cz>
 * date: 2015
 */
%{

//XXX hack to make scanner compilation possible
//struct block_record ISN'T USED HERE
struct block_record {
        void *i;
};

#include "common.h" //return codes
#include "data_type.h" //have to be here
#include "parser.h" //generated by bison

char * copy_identifier(const char *id);
char deescape_char(char esc);
char * deescape_str(char *esc);
%}

%option warn
%option noyywrap
 /* pairs with api.pure */
%option bison-bridge

%x ML_COMMENT

ESC \\[nt\\"']
CHAR [[:print:]]{-}[\\"']

%%

 /* Multi-line comments. */
"/*" { BEGIN(ML_COMMENT); }
<ML_COMMENT>{
        "*/" BEGIN(INITIAL);
        [^*\n]+ ;
        "*"[^/] ;
        \n ;
}

 /* Single-line comments. */
"//".* { }


 /* Keywords: */
"char" { return CHAR; }
"else" { return ELSE; }
"if" { return IF; }
"int" { return INT; }
"return" { return RETURN; }
"string" { return STRING; }
"void" { return VOID; }
"while" { return WHILE; }

 /* Reserved words: */
"break" { return BREAK; }
"continue" { return CONTINUE; }
"for" { return FOR; }
"short" { return SHORT; }
"unsigned" { return UNSIGNED; }

 /* Identifier. */
[a-zA-Z_][a-zA-Z_0-9]* { yylval->identifier = copy_identifier(yytext); return IDENTIFIER; }


 /* Integer literal (decimal only). */
[[:digit:]]+ { yylval->int_lit = atoi(yytext); return INT_LIT; }

 /* Character literal. */
'{ESC}' { yylval->char_lit = deescape_char(yytext[2]); return CHAR_LIT; }
'{CHAR}' { yylval->char_lit = yytext[1]; return CHAR_LIT; }

 /* String literal. */
\"({ESC}|{CHAR})*\" { yylval->string_lit = deescape_str(yytext); return STRING_LIT; }


 /* Other characters. */
"(" { return '('; }
")" { return ')'; }
"{" { return '{'; }
"}" { return '}'; }
"," { return ','; }
";" { return ';'; }
"=" { return '='; }

 /* Operators. */
"!" { return '!'; }
"*" { return '*'; }
"/" { return '/'; }
"%" { return '%'; }
"+" { return '+'; }
"-" { return '-'; }
"<" { return '<'; }
">" { return '>';}
"<=" { return LE_OP;}
">=" { return GE_OP;}
"==" { return EQ_OP;}
"!=" { return NE_OP;}
"&&" { return AND_OP;}
"||" { return OR_OP;}


 /* Eat up whitespaces. */
[[:space:]]+ { }

 /* Unknown. */
. { print_error(RET_LEXICAL, yytext, "unexpected symbol"); exit(RET_LEXICAL); }

%%

char * copy_identifier(const char *id)
{
        char *ret;


        assert(id != NULL);

        ret = strdup(id);
        if (ret == NULL) {
                print_error(RET_INTERNAL, __func__, "memory exhausted");
                exit(RET_INTERNAL);
        }


        return ret;
}

char deescape_char(char esc)
{
        assert(esc != '\0');

        switch (esc) {
        case 'n':
                return '\n';
        case 't':
                return '\t';
        default:
                return esc;
        }
}

char * deescape_str(char *esc)
{
        char *res;
        size_t res_end = 0;
        char cur;


        assert(esc != NULL);

        esc++; //remove facing "
        esc[strlen(esc) - 1] = '\0'; //remove trailing "

        /* Allocate memory for the whole string, maybe we will use less. */
        res = calloc(strlen(esc) + 1, sizeof (char));
        if (res == NULL) {
                print_error(RET_INTERNAL, __func__, "memory exhausted");
                exit(RET_INTERNAL);
        }

        while ((cur = *esc++)) { //while cur != null
                if (cur == '\\') { //escape sequence detected
                        cur = *esc++; //move to next character
                        cur = deescape_char(cur); //deescape it
                }

                res[res_end++] = cur; //append it to the deescaped string
        }


        return res;
}
